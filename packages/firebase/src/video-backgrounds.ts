/**
 * Video Backgrounds service for managing landing page video backgrounds
 * Used by admin app for CRUD and consumer apps for fetching
 */

import {
  collection,
  doc,
  getDocs,
  getDoc,
  setDoc,
  updateDoc,
  deleteDoc,
  query,
  orderBy,
  onSnapshot,
  serverTimestamp,
  Timestamp,
  type Unsubscribe,
} from 'firebase/firestore';
import {
  ref,
  uploadBytesResumable,
  getDownloadURL,
  deleteObject,
  type UploadTaskSnapshot,
} from 'firebase/storage';
import { db, storage } from './client';

const COLLECTION_NAME = 'video-backgrounds';

/**
 * Video variant metadata (generated by Cloud Function)
 */
export interface VideoVariant {
  quality: '1080p' | '720p';
  format: 'mp4' | 'webm';
  storagePath: string;
  downloadURL: string;
  fileSize: number;
  width: number;
  height: number;
}

/**
 * Processing status for background transcoding jobs
 */
export interface VideoProcessingStatus {
  status: 'pending' | 'processing' | 'completed' | 'failed';
  startedAt?: Date;
  completedAt?: Date;
  error?: string;
}

/**
 * Connection quality estimation
 */
export type ConnectionQuality = 'slow' | 'medium' | 'fast';

/**
 * Video source for multi-source video element
 */
export interface VideoSource {
  src: string;
  type: 'video/mp4' | 'video/webm';
}

/**
 * Generate a UUID with fallback for non-secure contexts (HTTP on local network)
 */
function generateUUID(): string {
  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
    return crypto.randomUUID();
  }
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

/**
 * Video background document stored in Firestore
 */
export interface VideoBackgroundDoc {
  id: string;
  name: string;
  description?: string;
  storagePath: string;
  downloadURL: string;
  posterStoragePath?: string;
  posterURL?: string;
  /** File size in bytes */
  fileSize: number;
  /** Duration in seconds (if available) */
  duration?: number;
  /** Recommended overlay opacity for this video */
  recommendedOverlay?: number;
  /** Tags for organization */
  tags: string[];
  /** Which app this video is assigned to (optional) */
  assignedApp?: string;
  uploadedBy: string;
  uploadedAt: Date;
  updatedAt: Date;
  active: boolean;
  /** Video variants (generated by Cloud Function) */
  variants?: VideoVariant[];
  /** Processing status for transcoding */
  processingStatus?: VideoProcessingStatus;
}

/**
 * Input for creating a new video background
 */
export interface VideoBackgroundCreateInput {
  name: string;
  description?: string;
  tags?: string[];
  recommendedOverlay?: number;
  assignedApp?: string;
}

/**
 * Input for updating a video background
 */
export interface VideoBackgroundUpdateInput {
  name?: string;
  description?: string;
  tags?: string[];
  recommendedOverlay?: number;
  assignedApp?: string;
  active?: boolean;
}

/**
 * Progress callback for upload
 */
export type UploadProgressCallback = (progress: number) => void;

/**
 * Convert Firestore document to VideoBackgroundDoc
 */
function docToVideoBackground(
  id: string,
  data: Record<string, unknown>
): VideoBackgroundDoc {
  return {
    id,
    name: data.name as string,
    description: data.description as string | undefined,
    storagePath: data.storagePath as string,
    downloadURL: data.downloadURL as string,
    posterStoragePath: data.posterStoragePath as string | undefined,
    posterURL: data.posterURL as string | undefined,
    fileSize: data.fileSize as number,
    duration: data.duration as number | undefined,
    recommendedOverlay: data.recommendedOverlay as number | undefined,
    tags: (data.tags as string[]) || [],
    assignedApp: data.assignedApp as string | undefined,
    uploadedBy: data.uploadedBy as string,
    uploadedAt:
      data.uploadedAt instanceof Timestamp
        ? data.uploadedAt.toDate()
        : new Date(),
    updatedAt:
      data.updatedAt instanceof Timestamp
        ? data.updatedAt.toDate()
        : new Date(),
    active: (data.active as boolean) ?? true,
  };
}

/**
 * Upload a new video background with progress tracking
 */
export async function uploadVideoBackground(
  videoFile: File,
  metadata: VideoBackgroundCreateInput,
  uploadedBy: string,
  onProgress?: UploadProgressCallback,
  posterFile?: File
): Promise<VideoBackgroundDoc> {
  const videoId = generateUUID();
  const extension = videoFile.name.split('.').pop() || 'mp4';
  const storagePath = `video-backgrounds/${videoId}.${extension}`;

  // Upload video to Storage with progress tracking
  const storageRef = ref(storage, storagePath);
  const uploadTask = uploadBytesResumable(storageRef, videoFile, {
    contentType: videoFile.type || 'video/mp4',
    customMetadata: {
      originalName: videoFile.name,
    },
  });

  // Track upload progress
  await new Promise<UploadTaskSnapshot>((resolve, reject) => {
    uploadTask.on(
      'state_changed',
      (snapshot) => {
        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
        onProgress?.(progress);
      },
      (error) => reject(error),
      () => resolve(uploadTask.snapshot)
    );
  });

  // Get download URL
  const downloadURL = await getDownloadURL(storageRef);

  // Upload poster image if provided
  let posterStoragePath: string | undefined;
  let posterURL: string | undefined;

  if (posterFile) {
    const posterExtension = posterFile.name.split('.').pop() || 'jpg';
    posterStoragePath = `video-backgrounds/${videoId}-poster.${posterExtension}`;
    const posterRef = ref(storage, posterStoragePath);
    await uploadBytesResumable(posterRef, posterFile, {
      contentType: posterFile.type || 'image/jpeg',
    });
    posterURL = await getDownloadURL(posterRef);
  }

  // Create Firestore document
  const videoDoc = {
    name: metadata.name,
    description: metadata.description || null,
    storagePath,
    downloadURL,
    posterStoragePath: posterStoragePath || null,
    posterURL: posterURL || null,
    fileSize: videoFile.size,
    recommendedOverlay: metadata.recommendedOverlay ?? 0.4,
    tags: metadata.tags || [],
    assignedApp: metadata.assignedApp || null,
    uploadedBy,
    uploadedAt: serverTimestamp(),
    updatedAt: serverTimestamp(),
    active: true,
  };

  await setDoc(doc(db, COLLECTION_NAME, videoId), videoDoc);

  return {
    id: videoId,
    ...videoDoc,
    uploadedAt: new Date(),
    updatedAt: new Date(),
    active: true,
  } as VideoBackgroundDoc;
}

/**
 * Update video background metadata
 */
export async function updateVideoBackground(
  videoId: string,
  updates: VideoBackgroundUpdateInput
): Promise<void> {
  const docRef = doc(db, COLLECTION_NAME, videoId);

  // Filter out undefined values and convert to null for Firestore
  const cleanUpdates: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(updates)) {
    cleanUpdates[key] = value === undefined ? null : value;
  }

  await updateDoc(docRef, {
    ...cleanUpdates,
    updatedAt: serverTimestamp(),
  });
}

/**
 * Delete a video background (removes from both Storage and Firestore)
 */
export async function deleteVideoBackground(videoId: string): Promise<void> {
  // Get the document first to get the storage paths
  const docRef = doc(db, COLLECTION_NAME, videoId);
  const docSnap = await getDoc(docRef);

  if (!docSnap.exists()) {
    throw new Error('Video background not found');
  }

  const data = docSnap.data();

  // Delete video from Storage
  if (data.storagePath) {
    try {
      const storageRef = ref(storage, data.storagePath as string);
      await deleteObject(storageRef);
    } catch (error) {
      console.warn('Failed to delete video file:', error);
    }
  }

  // Delete poster from Storage
  if (data.posterStoragePath) {
    try {
      const posterRef = ref(storage, data.posterStoragePath as string);
      await deleteObject(posterRef);
    } catch (error) {
      console.warn('Failed to delete poster file:', error);
    }
  }

  // Delete from Firestore
  await deleteDoc(docRef);
}

/**
 * Get all video backgrounds
 */
export async function getVideoBackgrounds(): Promise<VideoBackgroundDoc[]> {
  const q = query(
    collection(db, COLLECTION_NAME),
    orderBy('uploadedAt', 'desc')
  );

  const snapshot = await getDocs(q);
  return snapshot.docs.map((doc) => docToVideoBackground(doc.id, doc.data()));
}

/**
 * Get active video backgrounds only
 */
export async function getActiveVideoBackgrounds(): Promise<VideoBackgroundDoc[]> {
  const all = await getVideoBackgrounds();
  return all.filter((v) => v.active);
}

/**
 * Get a single video background by ID
 */
export async function getVideoBackgroundById(
  videoId: string
): Promise<VideoBackgroundDoc | null> {
  const docRef = doc(db, COLLECTION_NAME, videoId);
  const docSnap = await getDoc(docRef);

  if (!docSnap.exists()) {
    return null;
  }

  return docToVideoBackground(docSnap.id, docSnap.data());
}

/**
 * Get video background by assigned app
 */
export async function getVideoBackgroundByApp(
  appName: string
): Promise<VideoBackgroundDoc | null> {
  const all = await getVideoBackgrounds();
  return all.find((v) => v.assignedApp === appName && v.active) || null;
}

/**
 * Subscribe to video backgrounds with real-time updates
 */
export function subscribeToVideoBackgrounds(
  callback: (videos: VideoBackgroundDoc[]) => void
): Unsubscribe {
  const q = query(
    collection(db, COLLECTION_NAME),
    orderBy('uploadedAt', 'desc')
  );

  return onSnapshot(q, (snapshot) => {
    const videos = snapshot.docs.map((doc) =>
      docToVideoBackground(doc.id, doc.data())
    );
    callback(videos);
  });
}

/**
 * Toggle video background active status
 */
export async function toggleVideoBackgroundActive(
  videoId: string,
  active: boolean
): Promise<void> {
  await updateVideoBackground(videoId, { active });
}

/**
 * Assign video to an app
 */
export async function assignVideoToApp(
  videoId: string,
  appName: string | null
): Promise<void> {
  await updateVideoBackground(videoId, { assignedApp: appName || undefined });
}

/**
 * Upload poster image for an existing video
 */
export async function uploadVideoPoster(
  videoId: string,
  posterFile: File
): Promise<string> {
  const docRef = doc(db, COLLECTION_NAME, videoId);
  const docSnap = await getDoc(docRef);

  if (!docSnap.exists()) {
    throw new Error('Video background not found');
  }

  const data = docSnap.data();

  // Delete old poster if exists
  if (data.posterStoragePath) {
    try {
      const oldPosterRef = ref(storage, data.posterStoragePath as string);
      await deleteObject(oldPosterRef);
    } catch (error) {
      console.warn('Failed to delete old poster:', error);
    }
  }

  // Upload new poster
  const posterExtension = posterFile.name.split('.').pop() || 'jpg';
  const posterStoragePath = `video-backgrounds/${videoId}-poster.${posterExtension}`;
  const posterRef = ref(storage, posterStoragePath);
  await uploadBytesResumable(posterRef, posterFile, {
    contentType: posterFile.type || 'image/jpeg',
  });
  const posterURL = await getDownloadURL(posterRef);

  // Update Firestore
  await updateDoc(docRef, {
    posterStoragePath,
    posterURL,
    updatedAt: serverTimestamp(),
  });

  return posterURL;
}

/**
 * Format file size for display
 */
export function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

/**
 * Estimate connection quality using Navigator.connection API
 */
export function estimateConnectionQuality(): ConnectionQuality {
  if (typeof navigator === 'undefined') return 'medium';

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const connection = (navigator as any).connection;
  if (!connection) return 'medium';

  const effectiveType = connection.effectiveType;
  const downlink = connection.downlink;

  if (effectiveType === 'slow-2g' || effectiveType === '2g') return 'slow';
  if (effectiveType === '3g' || downlink < 1.5) return 'slow';
  if (effectiveType === '4g' && downlink >= 5) return 'fast';

  return 'medium';
}

/**
 * Get the best video variant based on viewport and connection quality
 */
export function getBestVideoVariant(
  video: VideoBackgroundDoc,
  viewportWidth: number,
  connectionQuality: ConnectionQuality = 'medium'
): { url: string; format: 'mp4' | 'webm' } {
  // No variants available - use original
  if (!video.variants || video.variants.length === 0) {
    return { url: video.downloadURL, format: 'mp4' };
  }

  // Determine target quality based on viewport and connection
  const preferWebm = connectionQuality === 'slow';
  const prefer720p = viewportWidth <= 1280 || connectionQuality === 'slow';

  const targetQuality = prefer720p ? '720p' : '1080p';
  const targetFormat = preferWebm ? 'webm' : 'mp4';

  // Try exact match first
  let variant = video.variants.find(
    (v) => v.quality === targetQuality && v.format === targetFormat
  );

  // Fallback: same quality, different format
  if (!variant) {
    variant = video.variants.find((v) => v.quality === targetQuality);
  }

  // Fallback: any variant
  if (!variant) {
    variant = video.variants[0];
  }

  return {
    url: variant.downloadURL,
    format: variant.format,
  };
}

/**
 * Get video source elements for all available formats
 * Returns sources in priority order: WebM (smaller) first, then MP4
 */
export function getVideoSourceElements(video: VideoBackgroundDoc): VideoSource[] {
  const sources: VideoSource[] = [];

  if (video.variants && video.variants.length > 0) {
    // Add 720p WebM first (smallest file size)
    const webm720 = video.variants.find((v) => v.quality === '720p' && v.format === 'webm');
    if (webm720) {
      sources.push({ src: webm720.downloadURL, type: 'video/webm' });
    }

    // Add 720p MP4
    const mp4_720 = video.variants.find((v) => v.quality === '720p' && v.format === 'mp4');
    if (mp4_720) {
      sources.push({ src: mp4_720.downloadURL, type: 'video/mp4' });
    }

    // Add 1080p MP4 as higher quality option
    const mp4_1080 = video.variants.find((v) => v.quality === '1080p' && v.format === 'mp4');
    if (mp4_1080) {
      sources.push({ src: mp4_1080.downloadURL, type: 'video/mp4' });
    }
  }

  // Always include original as final fallback
  if (sources.length === 0 || !sources.find((s) => s.src === video.downloadURL)) {
    sources.push({ src: video.downloadURL, type: 'video/mp4' });
  }

  return sources;
}

/**
 * Check if video processing is complete
 */
export function isVideoProcessed(video: VideoBackgroundDoc): boolean {
  return video.processingStatus?.status === 'completed' && !!video.variants?.length;
}

/**
 * Check if video processing failed
 */
export function isVideoProcessingFailed(video: VideoBackgroundDoc): boolean {
  return video.processingStatus?.status === 'failed';
}

/**
 * Check if video is currently being processed
 */
export function isVideoProcessing(video: VideoBackgroundDoc): boolean {
  return (
    video.processingStatus?.status === 'processing' ||
    video.processingStatus?.status === 'pending'
  );
}
